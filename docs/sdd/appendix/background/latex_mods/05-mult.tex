\subsubsection{Multiplication} Binary multiplication of Galois operands is
congruent to the sum of the indices of the operands. If the indices sum to
greater than or equal to $2^{n}-1$, then $2^{n}-1$ is subtracted from the sum
to prevent overflow.
\begin{align*}
    \alpha^{i} \cdot \alpha^{j} & = \{ x_{i, n-1}, \ldots, x_{i, 2}, x_{i, 1},
    x_{i, 0} \} \cdot \{x_{j, n-1}, \ldots, x_{j, 2}, x_{j, 1}, x_{j, 0}\} \\
    & = \alpha^{(i + j) \ mod \ (2^{n}-1)} \\
    & = \begin{cases}
            \alpha^{(i + j) - (2^{n}-1)} & \text{if $(i + j) \geq 2^{n}-1$} \\
            \alpha^{(i + j)} & \text{if $(i + j) < 2^{n}-1$}
        \end{cases}
\end{align*}

    \paragraph{{\small Digital Design}} \leavevmode \\ Only element forms of
    inputs are valid for this operation.

    Galois multiplication requires multiple binary additions and condition
    checks. To find the product of $\alpha^{i}$ and $\alpha^{j}$,
    a carry-lookahead adder may be used to sum the elements $i+j$. The most
    significant bits of the sum and the sum $+1$ will then be OR-ed to compute
    a single-bit control signal. The control signal will be multiplexed with a
    binary $1$ to be added to the sum.
\begin{align*}
    \alpha^{i} \cdot \alpha^{j} & = \{ x_{i, n-1}, \ldots, x_{i, 2}, x_{i, 1},
    x_{i, 0} \} \cdot \{x_{j, n-1}, \ldots, x_{j, 2}, x_{j, 1}, x_{j, 0}\} \\
    & \Longrightarrow \text{Let } n = |i| = |j| \\
    % & \Longrightarrow b = i + j \\
    % & \Longrightarrow c = b[n+1] \vee (b+1)[n+1] \\
    % & \Longrightarrow d = c \wedge 1 \\
    % & \Longrightarrow k = d + b \\
    % & \Longrightarrow k = i + j + \Big(1 \ \wedge \ \big((i+j)[n+1] \ \vee \
    % (i+j+1)[n+1]\big)\Big) \\
    % & = \alpha^{k} \\
    & = \begin{cases}
            \alpha^{(i + j)} & \text{if $\Big((i+j)[n+1] \ \vee \
            (i+j+1)[n+1]\Big)=0$} \\
            \alpha^{(i + j + 1)} & \text{if $\Big((i+j)[n+1] \ \vee \
            (i+j+1)[n+1]\Big)=1$}
        \end{cases}
\end{align*}
